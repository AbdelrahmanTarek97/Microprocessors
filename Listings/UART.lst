C51 COMPILER V9.59.0.0   UART                                                              11/17/2018 22:52:15 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\UART.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE UART.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\UART
                    -.lst) TABS(2) OBJECT(.\Objects\UART.obj)

line level    source

   1          #include<reg51.h>
   2          #include <stdlib.h>
   3          
   4          void uart_init();       //Initialize UART
   5          void timer_init();      // Timer 2 in mode 2 used for initialization of UART
   6          void uart_tx(char x);   //Transmission function
   7          char uart_rx();         //Receiving function
   8          void uart_msg(char *p); //String transmission
   9          void wait4Letter(char x); // A method that waits until the desired letter is entered 
  10          void startTimer(); // Start the timer so the overFlows are calculated by the interrupts
  11          void endTimer(); // Stop the timer
  12          void Timer0_ISR(void); // A method that detects the interrupts in the timer
  13          void trainUserX(bit user); // A method that lets a certain user to enter .tie5Ronal five times
  14          void testingPhase(); // A method that enables any user to enter .tie5Ronal for testing 
  15          long getEuclideanDistance(bit user); // A method that gets the euclidean difference between a ceratin user
             - and the tested user
  16          
  17          unsigned overFlows = 0; // This is our unit time in the program. It is the difference between a key stroke
             - and another
  18          unsigned long xdata avg0[9] ; //store average keystrokes for user 1
  19          unsigned long xdata avg1[9];//store average keystrokes for user 2
  20          unsigned long xdata testingTimes[9]; //store testing time of random user
  21          unsigned char password  [10] = ".tie5Ronal";  //The password the users will enter
  22          unsigned long euclideanDistance0 = 0 ; // The euclidean distance between user 0 and the random user
  23          unsigned long euclideanDistance1 = 0 ;// The euclidean distance between user 1 and the random user
  24          
  25          sbit switch1 = P0^0; // Switch 1 which indicates whether we are in training(0) or testing(1) Phase
  26          sbit switch2 = P0^1; // Switch 2 which indicates whether user0(0) or user1(1) is entering the password now
             - (In Training phase)
  27          sbit led = P0^2; // The Led which indicates which user is the random user. Lights up 1 time means User 0, 
             -2 times means User 1
  28          
  29          void main(void){
  30   1        
  31   1      
  32   1        led = 0; // The Led is off at the begining
  33   1        
  34   1        // Initialize UART settings 
  35   1        uart_init();
  36   1        
  37   1        uart_msg("Set Switch 1 to Train(0) and Switch 2 to User 0 \n");
  38   1                
  39   1        while(switch1 != 0 || switch2 != 0); // Wait until the Switch 1 is 0 (Training Phase) and Switch 2 is 0 (
             -User 0)
  40   1            
  41   1        uart_msg("Training User 0 \n");
  42   1            
  43   1        trainUserX(0); // Train User 0
  44   1          
  45   1        uart_msg("Set Switch 1 to Train(0) and Switch 2 to User 1 \n");
  46   1                
  47   1        while(switch1 != 0 || switch2 != 1); // Wait until the Switch 1 is 0 (Training Phase) and Switch 2 is 0 (
             -User 1)
  48   1      
C51 COMPILER V9.59.0.0   UART                                                              11/17/2018 22:52:15 PAGE 2   

  49   1        uart_msg("training User 1 \n"); 
  50   1          
  51   1        trainUserX(1); // Train User 1
  52   1            
  53   1        uart_msg("Set Switch 1 to Test(1)  \n");
  54   1      
  55   1        while(switch1 != 1); // Wait until the Switch 1 is 1 (Testing Phase)
  56   1        
  57   1        
  58   1        while(1)
  59   1        {
  60   2          uart_msg("Testing, Enter the password \n"); 
  61   2          
  62   2          testingPhase(); // Testing random user
  63   2          
  64   2          euclideanDistance0 = getEuclideanDistance(0); // Get the Euclidean Distance between User 0 and Testing U
             -ser
  65   2          euclideanDistance1 = getEuclideanDistance(1); // Get the Euclidean Distance between User 1 and Testing U
             -ser
  66   2      
  67   2          if(euclideanDistance1 > euclideanDistance0){ // If Euclidean Distance of User 1 is bigger than User 0 th
             -en the random user is User 0
  68   3            uart_msg("You are User 0 \n");
  69   3      
  70   3            // TURN THE LED ON ONCE AND THEN OFF //
  71   3            
  72   3            led = 1; // Turn the LED On
  73   3      
  74   3            startTimer();
  75   3            while(overFlows < 50); // Wait for 50 overflow units
  76   3            endTimer();
  77   3          
  78   3            led = 0; // Turn The Led Off
  79   3          
  80   3          } else if(euclideanDistance1 < euclideanDistance0){ // If Euclidean Distance of User 1 is smaller than U
             -ser 0 then the random user is User 1
  81   3            uart_msg("You are User 1 \n");
  82   3          
  83   3            // TURN THE LED ON AND THEN OFF AND THEN ON AND THEN OFF //
  84   3            
  85   3            led = 1; // Turn the LED on
  86   3            
  87   3            startTimer();
  88   3            while(overFlows < 50); // Wait for 50 overflow units
  89   3            endTimer();
  90   3            
  91   3            led = 0; // Turn the LED off
  92   3            
  93   3            startTimer();
  94   3            while(overFlows < 50); // Wait for 50 overflow units
  95   3            endTimer();
  96   3            
  97   3            led = 1; // Turn the LED on
  98   3            
  99   3            startTimer();
 100   3            while(overFlows < 50); // Wait for 50 overflow units
 101   3            endTimer();
 102   3            
 103   3            led = 0; // Turn the LED off
 104   3            
 105   3          } else { // If both euclidean distance is the same then we cannot know the random user
 106   3            uart_msg("I do not know! \n");
C51 COMPILER V9.59.0.0   UART                                                              11/17/2018 22:52:15 PAGE 3   

 107   3          }
 108   2        
 109   2        }
 110   1      
 111   1      }
 112          
 113          // A method that enables any user to enter .tie5Ronal for testing 
 114          void trainUserX (bit user){
 115   1      
 116   1        unsigned char j;
 117   1        unsigned char i;
 118   1        
 119   1        // First Check That there are no values in avg array by clearing it 
 120   1        for( i = 0; i<9; i++){
 121   2          if(!user){
 122   3            avg0[i] = 0;
 123   3          } else{
 124   3            avg1[i] = 0;
 125   3          }
 126   2        }
 127   1        // For each trial and here we have 5 trials
 128   1        for(j = '0'; j<'5' ; j++){
 129   2          uart_msg("trial ");
 130   2          uart_tx(j);
 131   2          uart_msg("\n");
 132   2          
 133   2          wait4Letter(password[0]);
 134   2                    
 135   2          // For each letter and we have 10 letters
 136   2          for( i = 0; i<9;i++){
 137   3                      
 138   3            startTimer(); // Let the timer start so we can count the over flows
 139   3            wait4Letter(password[i+1]); // Wait util the user enters the desired letter
 140   3            endTimer(); // End timer
 141   3            // Add all the overflows of every corresponding character in the 5 trials and we will later on divide t
             -hem by 5(No of Trials)
 142   3            if(!user){ 
 143   4              avg0[i] += (unsigned long)((((unsigned long)overFlows) << 16) | (((unsigned long)TH0) << 8) | ((unsign
             -ed long)TL0))/5;
 144   4              //avg0[i] += overFlows/5;
 145   4            } else if(user){
 146   4              avg1[i] += (unsigned long)((((unsigned long)overFlows) << 16) | (((unsigned long)TH0) << 8) | ((unsign
             -ed long)TL0))/5;
 147   4              //avg1[i] += overFlows/5;
 148   4            }
 149   3            overFlows = 0; // Reset overFlows to 0
 150   3              
 151   3          }
 152   2            uart_msg("\n");         
 153   2        }
 154   1        
 155   1      }
 156          
 157          // A method that enables any user to enter .tie5Ronal for testing 
 158          void testingPhase(){
 159   1        
 160   1        unsigned char i;
 161   1      
 162   1        // First Check That there are no values in testing array by clearing it 
 163   1        for( i = 0; i<9; i++){
 164   2          testingTimes[i] = 0;
 165   2        }
C51 COMPILER V9.59.0.0   UART                                                              11/17/2018 22:52:15 PAGE 4   

 166   1      
 167   1        wait4Letter(password[0]);
 168   1        
 169   1        // For each letter and we have 5 letters
 170   1        for( i = 0; i<9;i++){
 171   2                      
 172   2          startTimer(); // Start timers so we can count the overflows
 173   2          wait4Letter(password[i+1]); // Wait until random user enter the desired letter 
 174   2          endTimer(); // Stop timer
 175   2                      
 176   2          testingTimes[i] = (unsigned long)((((unsigned long)overFlows) << 16) | (((unsigned long)TH0) << 8) | ((u
             -nsigned long)TL0));
 177   2          
 178   2          //testingTimes[i] = overFlows;
 179   2          
 180   2          overFlows = 0;
 181   2              
 182   2        }
 183   1        uart_msg("\n");
 184   1        
 185   1      }
 186          
 187          // A method that waits until the desired letter is entered 
 188          void wait4Letter(char x){
 189   1      
 190   1        while(1){
 191   2          char y = uart_rx(); // Get Entered Letter
 192   2          
 193   2          // If the entered letter is as the desired letter then return else then keep looping until desired lette
             -r is entered
 194   2          if(y == x){
 195   3            uart_tx(x);
 196   3            return;
 197   3          }
 198   2          else{
 199   3      //      uart_msg(" Wrong character ! / ");
 200   3          }
 201   2        }
 202   1      }
 203          
 204          // A method that gets the euclidean difference between a ceratin user and the tested user
 205          long getEuclideanDistance(bit user){
 206   1        unsigned char i;
 207   1      
 208   1        unsigned long euclideanDistance = 0;
 209   1        
 210   1        for(i=0;i<9;i++){
 211   2          
 212   2          if(!user){ // The Euclidean Distance is calculated by squaring the difference between two points
 213   3            //euclideanDistance += (testingTimes[i] - avg0[i])*(testingTimes[i] - avg0[i]);
 214   3            euclideanDistance += abs(testingTimes[i] - avg0[i]);
 215   3          } else {
 216   3            //euclideanDistance += (testingTimes[i] - avg1[i]) * (testingTimes[i] - avg1[i]);
 217   3            euclideanDistance += abs(testingTimes[i] - avg1[i]);
 218   3          }
 219   2          
 220   2        }
 221   1      
 222   1        return euclideanDistance;
 223   1        
 224   1      }
 225          
C51 COMPILER V9.59.0.0   UART                                                              11/17/2018 22:52:15 PAGE 5   

 226          //String transmission
 227          void uart_msg(char *p){
 228   1        
 229   1        while(*p != 0){
 230   2          uart_tx(*p);
 231   2          p++;
 232   2        }
 233   1        
 234   1        return;
 235   1        
 236   1      }
 237          
 238          // Start the timer so the overFlows are calculated by the interrupts
 239          void startTimer(){
 240   1        overFlows = 0; // Clearing the overFlows
 241   1        TH0 = 0x00; // Restarting the timer high bits of timer 0 
 242   1        TL0 = 0x00; // Restarting the timer low bits of timer 0
 243   1        TR0 = 1; // Start timer 0
 244   1        ET0 = 1; // Enable timer 0 interruprs
 245   1        EA = 1; // Enable Interrupts
 246   1      }
 247          
 248          // Stop the timer
 249          void endTimer(){
 250   1        TR0 = 0; // Stop Timer 0 interrupts
 251   1        ET0 = 0; // Disable Timer 0 interrupts
 252   1        EA = 0; // Disable Interrupts
 253   1      }
 254          
 255          //Initialize UART
 256          void uart_init(){
 257   1         SCON = 0x50;
 258   1         timer_init();
 259   1      }
 260          
 261          // Timer 2 in mode 2 used for initialization of UART
 262          void timer_init(){
 263   1        TMOD = 0x21;
 264   1        TH1 = 0xFD;
 265   1        TR1 = 1;
 266   1      }
 267          
 268          //Transmission function
 269          void uart_tx(char x){
 270   1        SBUF = x;
 271   1        
 272   1        while(!TI);
 273   1        
 274   1        TI = 0;
 275   1      }
 276          
 277          //Receiving function
 278          char uart_rx(){
 279   1        char x;
 280   1        //REN = 1;
 281   1        while(!RI);
 282   1        x = SBUF;
 283   1        RI = 0;
 284   1        return x;
 285   1      }
 286          
 287          // A method that detects the interrupts in the timer
C51 COMPILER V9.59.0.0   UART                                                              11/17/2018 22:52:15 PAGE 6   

 288          void Timer0_ISR(void) interrupt 1 {
 289   1        TR0 = 0;
 290   1        overFlows ++; // Incerement Overflows
 291   1        TH0 = 0x00;
 292   1        TL0 = 0x00;
 293   1        TF0 = 0;
 294   1        TR0 = 1;  
 295   1      }
 296          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1005    ----
   CONSTANT SIZE    =    253    ----
   XDATA SIZE       =    108    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
